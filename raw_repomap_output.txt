
conduit/cli/__init__.py

conduit/cli/commands/__init__.py

conduit/cli/commands/confluence.py:
⋮
│@click.group()
│def confluence():
⋮
│@confluence.group()
│def pages():
⋮
│@pages.command()
⋮
│def list(space, limit, site):
⋮
│@pages.command()
⋮
│def content(space, format, depth, site):
⋮
│@pages.command()
⋮
│def list_all(space_key: str, batch_size: int, site: str):
⋮
│@pages.command()
⋮
│def children(parent_id: str, site: str):
⋮
│@pages.command()
⋮
│def get(space_key: str, title: str, format: str, site: str):
⋮

conduit/cli/commands/jira.py:
⋮
│@click.group()
│def jira():
⋮
│@jira.group()
│def issue():
⋮
│@issue.command()
⋮
│def get(key, site):
⋮
│@issue.command()
⋮
│def search(query, site):
⋮
│@issue.command()
⋮
│def create(project, summary, content_file, type, site):
⋮
│@issue.command()
⋮
│def update(key, summary, description, content_file, site):
⋮
│@issue.command()
⋮
│def comment(key, content_file, site):
⋮
│@issue.command()
⋮
│def status(key, status, site):
⋮
│@issue.command()
⋮
│def remote_links(key, site):
⋮
│@jira.command()
⋮
│def get_boards(project, site):
⋮
│@jira.command()
⋮
│def get_sprints(board_id, state, site):
⋮
│@jira.command()
⋮
│def add_to_sprint(sprint_id, issues, site):
⋮

conduit/cli/main.py:
⋮
│def handle_error(func):
│    """Error handling decorator for CLI commands."""
│
│    @functools.wraps(func)
│    def wrapper(*args, **kwargs):
⋮
│def init_config():
⋮
│class ConduitCLI(click.Group):
│    """Custom Click Group that handles global flags without requiring commands."""
│
│    def invoke(self, ctx):
⋮
│@click.group(cls=ConduitCLI)
⋮
│def cli(verbose, init, json, version):
⋮
│@cli.group()
│def config():
⋮
│@config.command()
│@handle_error
│def clean():
⋮
│@config.command()
⋮
│def list(platform):
│    """List configured Atlassian sites.
│
│    Shows all configured Jira and Confluence sites with their connection details.
│    Sensitive information like API tokens is masked for security.
│
│    Examples:
│      $ conduit config list
│      $ conduit config list --platform jira
│      $ conduit config list --platform confluence
│    """
│    try:
│        config = load_config()
│
│        def format_site_info(platform_name, site_alias, site_config):
⋮
│@cli.command()
⋮
│def connect(platform_name, site):
⋮
│@cli.command()
│def get_content_path() -> None:
⋮
│@cli.command(name="mcp")
⋮
│def mcp_cmd(debug: bool, transport: str):
⋮

conduit/config/__init__.py

conduit/config/config.yaml

conduit/core/__init__.py

conduit/core/config.py:
⋮
│class SiteConfig(BaseModel):
⋮
│class JiraConfig(BaseModel):
│    """Jira configuration."""
│
⋮
│    class Config:
⋮
│    def get_site_config(self, site_alias: Optional[str] = None) -> SiteConfig:
⋮
│class ConfluenceConfig(BaseModel):
│    """Confluence configuration."""
│
⋮
│    class Config:
⋮
│    def get_site_config(self, site_alias: Optional[str] = None) -> SiteConfig:
⋮
│class Config(BaseModel):
│    """Base configuration class."""
│
⋮
│    def get_content_dir(self) -> Path:
⋮
│def get_config_dir() -> Path:
⋮
│def create_default_config(config_path: Path) -> None:
⋮
│def load_config() -> Config:
⋮

conduit/core/content.py:
⋮
│class ContentManager:
│    def __init__(self, content_dir: Path):
│        """Initialize the content manager with a directory for storing content files.
│
│        Args:
│            content_dir: Path to the directory where content files will be stored
│        """
│        self.content_dir = content_dir
│        self.content_dir.mkdir(parents=True, exist_ok=True)
│        self.failed_content_dir = content_dir / "failed_content"
│        self.failed_content_dir.mkdir(parents=True, exist_ok=True)
⋮
│    def generate_content_path(self) -> Path:
⋮
│    def write_content(self, file_path: Path, content: str) -> None:
⋮
│    def read_content(self, file_path: Path) -> str:
⋮
│    def cleanup_content_file(self, file_path: Path) -> None:
⋮
│    def mark_content_as_failed(self, file_path: Path) -> Path:
⋮

conduit/core/exceptions.py:
│class ConduitError(Exception):
⋮
│class ConfigurationError(ConduitError):
⋮
│class PlatformError(ConduitError):
⋮

conduit/core/logger.py:
⋮
│logger = logging.getLogger("conduit")

conduit/core/services.py:
⋮
│class ConfigService:
│    """Service layer for configuration operations"""
│
│    @classmethod
│    def list_configs(cls) -> Dict:
⋮
│class ConfluenceService:
│    """Service layer for Confluence operations"""
│
│    @classmethod
│    def _get_client(cls, site_alias: Optional[str] = None) -> ConfluenceClient:
⋮
│    @classmethod
│    async def list_pages(
│        cls, space_key: str, site_alias: Optional[str] = None
⋮
│    @classmethod
│    async def get_page(
│        cls, space_key: str, page_title: str, site_alias: Optional[str] = None
⋮
│    @classmethod
│    async def create_page_from_markdown(
│        cls,
│        space_key: str,
│        title: str,
│        content: str,
│        parent_id: Optional[str] = None,
│        site_alias: Optional[str] = None,
⋮
│    @classmethod
│    async def create_page_from_markdown_direct(
│        cls,
│        space_key: str,
│        title: str,
│        content: str,
│        parent_id: Optional[str] = None,
│        site_alias: Optional[str] = None,
│        update: bool = True,
│        minor_edit: bool = False,
│        version_comment: str = "Updated via Conduit",
⋮

conduit/mcp/__init__.py:
⋮
│__all__ = ["server", "create_mcp_server"]
│
⋮
│def main(transport: str = "stdio"):
⋮

conduit/mcp/server.py:
⋮
│logger = logging.getLogger("conduit.mcp")
│mcp_logger = logging.getLogger("mcp.server")
│uvicorn_logger = logging.getLogger("uvicorn")
│root_logger = logging.getLogger()
│
⋮
│stderr_handler = logging.StreamHandler(sys.stderr)
│stderr_handler.setLevel(logging.DEBUG)
│formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
⋮
│def create_mcp_server() -> FastMCP:
⋮
│def register_tools(mcp_server: FastMCP) -> None:
│    """Register all MCP tools with the server"""
│
│    @mcp_server.tool(
│        name="list_atlassian_sites",
│        description="List all configured Jira and Confluence sites conduit is configured to use",
│    )
│    async def list_config() -> list[types.TextContent]:
⋮
│    @mcp_server.tool(
│        name="get_confluence_page",
│        description="Get Confluence page content by title within a space, returning the content in markdown format",
│    )
│    async def get_confluence_page(
│        space_key: str, title: str, site_alias: Optional[Union[str, None]] = None
⋮
│    @mcp_server.tool(
│        name="search_jira_issues",
│        description="Search for Jira issues using JQL (Jira Query Language) syntax",
│    )
│    async def search_jira_issues(
│        query: str, site_alias: Optional[Union[str, None]] = None
⋮
│    @mcp_server.tool(
│        name="create_jira_issue",
│        description="Create a new Jira issue with specified project, summary, description and type",
│    )
│    async def create_jira_issue(
│        project: str,
│        summary: str,
│        description: str,
│        issue_type: str = "Task",
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="update_jira_issue",
│        description="Update an existing Jira issue's summary and description fields",
│    )
│    async def update_jira_issue(
│        key: str,
│        summary: str,
│        description: str,
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="update_jira_status",
│        description="Update a Jira issue's status (move it to a different workflow state)",
│    )
│    async def update_jira_status(
│        key: str,
│        status: str,
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="get_jira_boards",
│        description="Get all Jira boards, optionally filtered by project key",
│    )
│    async def get_jira_boards(
│        project_key: Optional[Union[str, None]] = None,
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="get_jira_sprints",
│        description="Get all sprints from a Jira board, optionally filtered by state (active, future, closed)",
│    )
│    async def get_jira_sprints(
│        board_id: int,
│        state: Optional[Union[str, None]] = None,
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="add_issues_to_jira_sprint",
│        description="Add one or more Jira issues to a specific sprint by ID",
│    )
│    async def add_issues_to_jira_sprint(
│        sprint_id: int,
│        issue_keys: List[str],
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="get_jira_remote_links",
│        description="Get all remote links (URLs, etc.) associated with a specific Jira issue",
│    )
│    async def get_jira_remote_links(
│        key: str,
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="list_all_confluence_pages",
│        description="List all pages in a Confluence space with pagination support, returning a formatted table of results",
│    )
│    async def list_all_confluence_pages(
│        space_key: str,
│        batch_size: int = 100,
│        site_alias: Optional[Union[str, None]] = None,
⋮
│    @mcp_server.tool(
│        name="create_confluence_page_from_markdown",
│        description="Create a new Confluence page from markdown content, automatically converting it to Confluence storage format",
│    )
│    async def create_confluence_page(
│        space: str,
│        title: str,
│        content: str,
│        parent_id: Optional[Union[str, int]] = None,
│        site_alias: Optional[Union[str, None]] = None,
⋮
│server = create_mcp_server()
│
⋮
│@click.command()
⋮
│def main(port: int, transport: str) -> int:
⋮

conduit/platforms/__init__.py

conduit/platforms/base.py:
⋮
│class Platform(ABC):
│    """Base class for all platform implementations."""
│    
│    @abstractmethod
│    def connect(self) -> None:
⋮
│    @abstractmethod
│    def disconnect(self) -> None:
⋮
│class IssueManager(ABC):
│    """Base class for issue management."""
│    
│    @abstractmethod
│    def get(self, key: str) -> Dict[str, Any]:
⋮
│    @abstractmethod
│    def search(self, query: str) -> list[Dict[str, Any]]:
⋮
│    @abstractmethod
│    def create(self, **kwargs) -> Dict[str, Any]:
⋮
│    @abstractmethod
│    def update(self, key: str, **kwargs) -> None:
⋮

conduit/platforms/confluence/__init__.py:
⋮
│__all__ = ["ConfluenceClient", "ConfluenceConfig"]

conduit/platforms/confluence/client.py:
⋮
│class ConfluenceClient(Platform):
│    """Client for interacting with Confluence."""
│
│    def __init__(
│        self,
│        config_or_site_alias: Optional[Union[ConfluenceConfig, str]] = None,
│        site_alias: Optional[str] = None,
⋮
│    def connect(self) -> None:
⋮
│    def disconnect(self) -> None:
⋮
│    def get_pages_by_space(
│        self, space_key: str, limit: int = 100, expand: Optional[str] = None
⋮
│    def get_all_pages_by_space(
│        self, space_key: str, expand: Optional[str] = None, batch_size: int = 100
⋮
│    def get_child_pages(
│        self, parent_id: str, limit: int = 100, expand: Optional[str] = None
⋮
│    def get_space_content(
│        self,
│        space_key: str,
│        depth: str = "all",
│        start: int = 0,
│        limit: int = 500,
│        expand: str = "body.storage",
│        format: str = "storage",
⋮
│    def get_page_by_title(
│        self, space_key: str, title: str, expand: Optional[str] = None
⋮
│    async def list_pages(self, space_key: str) -> List[Dict[str, Any]]:
⋮
│    async def create_page(
│        self,
│        space_key: str,
│        title: str,
│        body: str,
│        parent_id: Optional[str] = None,
│        representation: str = "storage",
⋮

conduit/platforms/confluence/config.py:
⋮
│@dataclass
│class ConfluenceConfig:
⋮

conduit/platforms/confluence/content.py:
⋮
│class ConfluenceContentCleaner:
│    """Clean and process Confluence storage format content."""
│
│    def clean_element(self, element: BeautifulSoup | NavigableString) -> str:
⋮
│    def clean(self, content: str) -> str:
⋮
│    def _post_process(self, text: str) -> str:
⋮

conduit/platforms/jira/__init__.py:
⋮
│__all__ = ["JiraConfig", "JiraClient"]

conduit/platforms/jira/client.py:
⋮
│class JiraClient(Platform, IssueManager):
│    def __init__(self, site_alias: Optional[str] = None):
│        try:
│            self.config = load_config().jira
│            self.site_alias = site_alias
│            self.jira = None
│            logger.info("Initialized Jira client")
│        except (FileNotFoundError, ConfigurationError) as e:
│            logger.error(f"Failed to initialize Jira client: {e}")
⋮
│    def connect(self) -> None:
⋮
│    def disconnect(self) -> None:
⋮
│    def get(self, key: str) -> Dict[str, Any]:
⋮
│    def search(self, query: str) -> list[Dict[str, Any]]:
⋮
│    def create(self, **kwargs) -> Dict[str, Any]:
⋮
│    def update(self, key: str, **kwargs) -> None:
⋮
│    def add_comment(self, key: str, comment: str) -> Dict[str, Any]:
⋮
│    def get_transitions(self, key: str) -> List[Dict[str, Any]]:
⋮
│    def transition_status(self, key: str, status: str) -> None:
⋮
│    def get_remote_links(self, key: str) -> List[Dict[str, Any]]:
⋮
│    def get_boards(self, project_key: Optional[str] = None) -> List[Dict[str, Any]]:
⋮
│    def get_sprints(
│        self, board_id: int, state: Optional[str] = None
⋮
│    def add_issues_to_sprint(self, sprint_id: int, issue_keys: List[str]) -> None:
⋮

conduit/platforms/jira/config.py:
⋮
│class JiraConfig(BaseModel):
⋮

conduit/platforms/jira/content.py:
⋮
│def markdown_to_jira(content: str) -> str:
⋮

conduit/platforms/registry.py:
⋮
│class PlatformRegistry:
│    _registry: Dict[str, Type[Platform]] = {}
│
│    @classmethod
│    def register(cls, name: str, platform_cls: Type[Platform]) -> None:
⋮
│    @classmethod
│    def get_platform(cls, name: str, site_alias: Optional[str] = None) -> Platform:
⋮

manual_testing/pylib_test.py

pylib_test.py

pyproject.toml

tests/cli/test_content_commands.py:
⋮
│@pytest.fixture
│def mock_config(tmp_path, monkeypatch):
│    """Create a mock configuration for testing."""
⋮
│    def mock_load_config():
⋮
│@pytest.fixture
│def cli_runner():
⋮
│def test_get_content_path(cli_runner, mock_config):
⋮
│def test_create_issue_with_content_file(cli_runner, mock_config, monkeypatch):
│    """Test creating an issue using a content file."""
⋮
│    class MockPlatform:
│        def connect(self):
⋮
│        def create(self, **kwargs):
⋮
│    def mock_get_platform(name, site_alias=None):
⋮
│def test_create_issue_nonexistent_content_file(cli_runner, mock_config):
⋮
│def test_create_issue_missing_required_options(cli_runner, mock_config):
⋮
│def test_update_issue_with_content_file(cli_runner, mock_config, monkeypatch):
│    """Test updating an issue using a content file."""
⋮
│    class MockPlatform:
│        def connect(self):
⋮
│        def update(self, key, **kwargs):
⋮
│    def mock_get_platform(name, site_alias=None):
⋮
│def test_add_comment_missing_content_file(cli_runner, mock_config):
⋮
│def test_add_comment_with_content_file(cli_runner, mock_config, monkeypatch):
│    """Test adding a comment using a content file."""
⋮
│    class MockPlatform:
│        def connect(self):
⋮
│        def add_comment(self, key, comment):
⋮
│    def mock_get_platform(name, site_alias=None):
⋮

tests/core/test_content.py:
⋮
│@pytest.fixture
│def temp_content_dir(tmp_path):
⋮
│@pytest.fixture
│def content_manager(temp_content_dir):
⋮
│def test_content_manager_init(temp_content_dir):
⋮
│def test_create_empty_content_file(content_manager):
⋮
│def test_create_content_file_with_content(content_manager):
⋮
│def test_create_multiple_content_files(content_manager):
⋮
│def test_generate_content_path(content_manager):
⋮
│def test_generate_multiple_content_paths(content_manager):
⋮
│def test_write_content(content_manager):
⋮
│def test_write_content_outside_directory(content_manager, tmp_path):
⋮
│def test_read_content_existing_file(content_manager):
⋮
│def test_read_content_nonexistent_file(content_manager):
⋮
│def test_content_dir_creation(tmp_path):
⋮
│def test_cleanup_content_file(content_manager):
⋮
│def test_cleanup_nonexistent_content_file(content_manager):
⋮
│def test_cleanup_content_file_outside_directory(content_manager, tmp_path):
⋮
│def test_mark_content_as_failed(content_manager):
⋮
│def test_mark_nonexistent_content_as_failed(content_manager):
⋮
│def test_mark_content_as_failed_outside_directory(content_manager, tmp_path):
⋮
│def test_failed_content_directory_creation(tmp_path):
⋮

tests/platforms/jira/test_client.py:
⋮
│@pytest.fixture
│def mock_config():
⋮
│@pytest.fixture
│def mock_jira():
⋮
│@pytest.fixture
│def jira_client(mock_config, mock_jira):
⋮
│def test_connect_success():
⋮
│def test_get_issue_success(jira_client):
⋮
│def test_search_issues_success(jira_client):
⋮
│def test_create_issue_failure(jira_client):
⋮
│def test_update_issue_success(jira_client):
⋮
│def test_get_transitions_success(jira_client):
⋮
│def test_transition_status_success(jira_client):
⋮
│def test_transition_status_invalid_status(jira_client):
⋮
│def test_transition_status_failure(jira_client):
⋮

